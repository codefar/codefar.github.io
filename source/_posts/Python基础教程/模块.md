---
layout: post
title: Python基础教程-包和模块
date: '2020-5-13 20:02'
categories: Python
tags: [Python]
description: Python学习
comments: true
---

# 包和模块

模块是用来组织 Python 代码的方法,  而包则是用来组织模块的。


## 什么是模块 
- 在交互模式下输出的变量和函数定义，一旦终端重启后，这些定义就都不存在了，为了持久保存这些变量、函数等的定义，Python中引入了模块（Module）的概念。一个Python模块其实就是以.py结尾的代码文件，一个文件被看作一个独立的模块，一个模块也可以被看作是一个文件。模块的文件名就是模块的名字加上扩展名.py。

- Python模块中存放的是一些程序代码，例如，变量定义、函数定义或是代码语句。

- Python每个模块都有模块属性 __name__ ，该属性存储了当前模块的名称，比如， hello.py 其__name__就是 'hello.py'

### 模块导入

在 python 用 import 或者 from...import 来导入相应的模块。

使用"import module"导入模块方式时，被导入模块不能带后缀；使用导入模块中定义的变量、函数时，必须使用模块名作为前缀，如"module.a"而不是直接使用"a"。如果感觉这样麻烦的，可以使用下面的方式，将模块中所有的定义信息全部导入。
  
- 将整个模块(somemodule)导入，格式为： import somemodule

- 从某个模块中导入某个函数,格式为： from somemodule import somefunction

- 从某个模块中导入多个函数,格式为： from somemodule import firstfunc, secondfunc, thirdfunc

- 将某个模块中的全部函数导入，格式为： from somemodule import *

### 4模块的相关信息

每个模块都有自己的定义信息，包括变量、函数等以及一些“与生俱来”的内建变量，这些可以通过Python内建函数 dir() 来查看。

直接在终端下输出dir()，输出当前环境下的变量名

```
>>> dir()  
['__builtins__', '__doc__', '__loader__', '__name__', '__package__', '__spec__']
```

使用dir()查看模块，不仅输出了默认的的变量名，还输出了hello.py中我定义的变量a和函数fun的名称


```
>>> import hello  
>>> dir(hello)  
['__builtins__', '__cached__', '__doc__', '__file__', '__loader__', '__name__', '__package__', '__spec__', 'a', 'fun']
```

常用信息 ： 

1. 模块代码的第一个字符串被视为模块的文档注释；
1. __author__ 模块作者
1. __name__=='__main__'  
通过命令行运行某个模块时，Python解释器把一个特殊变量__name__置为__main__，if判断将成功。
而如果在其他地方导入该hello模块时，if判断将失败。因此，我们可以通过这运行测试单模块。

```
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

' module description'  ## 模块的文档注释

__author__ = 'Python'  ## 模块作者

if __name__=='__main__':
    pass
```


### 模块导入顺序
当导入模块时，Python按照一定的搜索顺序在指定的目录下搜索模块，如果找到则导入模块，否则会引发异常。

例如，执行 “import hello”导入hello.py模块时，
Python解释器首先根据模块名搜索内建模块；  
如果没有找到，则会去sys.path变量所列出的目录下搜索。
sys.path的默认目录如下：
1. 输入脚本所在目录（或当前目录，如果没有指定导入脚本，如 import ×）
1. 环境变量 PYTHONPATH所指定的目录（这个与系统环境变量中的PATH语法相同
1. 安装的目录（默认）如果导入的脚本是一个符号连接（Windows上的快捷方式），搜索目录是符号链接所连接的原始文件所在目录，而非符号连接所在目录。在Python解释器初始化之后，可以在程序中修改 sys.path

## 包

包是Python用来管理模块命名空间的方式，用来存放其他的模块和包。其作用和java中的包相似，是为了防止命名冲突。包的物理表现就是一个目录（文件夹）。

一个目录只有包含一个叫做 __init__.py 的文件才会被认作是一个包。

这里给出了一种可能的包结构（在分层的文件系统中）:

```
sound/                          顶层包
      __init__.py               初始化 sound 包
      formats/                  文件格式转换子包
              __init__.py
              wavread.py
              wavwrite.py
              aiffread.py
              aiffwrite.py
              auread.py
              auwrite.py
              ...
      effects/                  声音效果子包
              __init__.py
              echo.py
              surround.py
              reverse.py
              ...
      filters/                  filters 子包
              __init__.py
              equalizer.py
              vocoder.py
              karaoke.py
              ...
```


