---
layout: post
title:HashMap
date: '2019-04-14 16:02'
categories: Java
tags: [Java]
description: HashMap
comments: true
---

# HashMap 这一篇就够了

https://zhuanlan.zhihu.com/p/143826469

## 二狗：先来点简单的，介绍下 HashMap 的底层数据结构吧。

囧辉：我们现在用的都是 JDK 1.8，底层是由“数组+链表+红黑树”组成，如下图，而在 JDK 1.8 之前是由“数组+链表”组成。

![https://pic4.zhimg.com/80/v2-bda10525571a333b96e9e465aaa7e717_1440w.jpg](https://pic4.zhimg.com/80/v2-bda10525571a333b96e9e465aaa7e717_1440w.jpg)

## 二狗：为什么要改成“数组+链表+红黑树”？
囧辉：主要是为了提升在 hash 冲突严重时（链表过长）的查找性能，使用链表的查找性能是 O(n)，而使用红黑树是 O(logn)。

## 二狗：那在什么时候用链表？什么时候用红黑树？
囧辉：对于插入，默认情况下是使用链表节点。当同一个索引位置的节点在新增后达到9个（阈值8）：如果此时数组长度大于等于 64，则会触发链表节点转红黑树节点（treeifyBin）；而如果数组长度小于64，则不会触发链表转红黑树，而是会进行扩容，因为此时的数据量还比较小。

对于移除，当同一个索引位置的节点在移除后达到 6 个，并且该索引位置的节点为红黑树节点，会触发红黑树节点转链表节点（untreeify）。

## 二狗：为什么链表转红黑树的阈值是8？
囧辉：我们平时在进行方案设计时，必须考虑的两个很重要的因素是：时间和空间。对于 HashMap 也是同样的道理，简单来说，阈值为8是在时间和空间上权衡的结果（这 B 我装定了）。

红黑树节点大小约为链表节点的2倍，在节点太少时，红黑树的查找性能优势并不明显，付出2倍空间的代价作者觉得不值得。

理想情况下，使用随机的哈希码，节点分布在 hash 桶中的频率遵循泊松分布，按照泊松分布的公式计算，链表中节点个数为8时的概率为 0.00000006（跟大乐透一等奖差不多，中大乐透？不存在的），这个概率足够低了，并且到8个节点时，红黑树的性能优势也会开始展现出来，因此8是一个较合理的数字。

## 二狗：（呦呦呦，时间和空间上权衡的结果，还装起B来了）那为什么转回链表节点是用的6而不是复用8？
囧辉：如果我们设置节点多于8个转红黑树，少于8个就马上转链表，当节点个数在8徘徊时，就会频繁进行红黑树和链表的转换，造成性能的损耗。

## 二狗：（小菜鸡，懂得还不少）那 HashMap 有哪些重要属性？分别用于做什么的？
囧辉：除了用来存储我们的节点 table 数组外，HashMap 还有以下几个重要属性：
1）size：HashMap 已经存储的节点个数；
2）threshold：扩容阈值，当 HashMap 的个数达到该值，触发扩容。
3）loadFactor：负载因子，扩容阈值 = 容量 * 负载因子。

## 二狗：threshold 除了用于存放扩容阈值还有其他作用吗？
囧辉：在我们新建 HashMap 对象时， threshold 还会被用来存初始化时的容量。HashMap 直到我们第一次插入节点时，才会对 table 进行初始化，避免不必要的空间浪费。

## 二狗：HashMap 的默认初始容量是多少？HashMap 的容量有什么限制吗？
囧辉：默认初始容量是16。HashMap 的容量必须是2的N次方，HashMap 会根据我们传入的容量计算一个大于等于该容量的最小的2的N次方，例如传 9，容量为16。

## 二狗：（你他娘的是在绕口令吧）你这个*@%￥#&的N次方是怎么算的？
囧辉：Talk is cheap. Show you the code。
```
static final int tableSizeFor(int cap) {
    int n = cap - 1;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
}
```

## 二狗：卧槽，还彪英文，来来来，这代码你给我解释下。
囧辉：我们先不看第一行“int n = cap - 1”，先看下面的5行计算。

|=（或等于）：这个符号比较少见，但是“+=”应该都见过，看到这你应该明白了。例如：a |= b ，可以转成：a = a | b。

>>>（无符号右移）：例如 a >>> b 指的是将 a 向右移动 b 指定的位数，右移后左边空出的位用零来填充，移出右边的位被丢弃。

假设 n 的值为 0010 0001，则该计算如下图：
![image](https://pic1.zhimg.com/80/v2-5e63c4df357c967aafc7fb33a3d1d768_1440w.jpg)

相信你应该看出来，这5个公式会通过最高位的1，拿到2个1、4个1、8个1、16个1、32个1。当然，有多少个1，取决于我们的入参有多大，但我们肯定的是经过这5个计算，得到的值是一个低位全是1的值，最后返回的时候 +1，则会得到1个比n 大的 2 的N次方。

这时再看开头的 cap - 1 就很简单了，这是为了处理 cap 本身就是 2 的N次方的情况。

计算机底层是二进制的，移位和或运算是非常快的，所以这个方法的效率很高。

PS：这是 HashMap 中我个人最喜欢的设计，非常巧妙，真想给作者一个么么哒（不小心暴露了）。


## 二狗：（这叼毛讲的还凑合啊，连我都听懂了）你说 HashMap 的容量必须是 2 的 N 次方，这是为什么？
囧辉：计算索引位置的公式为：(n - 1) & hash，当 n 为 2 的 N 次方时，n - 1 为低位全是 1 的值，此时任何值跟 n - 1 进行 & 运算会等于其本身，达到了和取模同样的效果，实现了均匀分布。实际上，这个设计就是基于公式：x mod 2^n = x & (2^n - 1)，因为 & 运算比 mod 具有更高的效率。

如下图，当 n 不为 2 的 N 次方时，hash 冲突的概率明显增大。
![image](https://pic3.zhimg.com/80/v2-550e1f8eb0e154bbec227af617556032_1440w.jpg)


## 二狗：你说 HashMap 的默认初始容量是 16，为什么是16而不是其他的？
囧辉：（这是什么煞笔问题）我认为是16的原因主要是：16是2的N次方，并且是一个较合理的大小。如果用8或32，我觉得也是OK的。实际上，我们在新建 HashMap 时，最好是根据自己使用情况设置初始容量，这才是最合理的方案。

## 二狗：刚才说的负载因子默认初始值又是多少？
囧辉：负载因子默认值是0.75。

二狗：为什么是0.75而不是其他的？
囧辉：（又问这种憨逼问题）这个也是在时间和空间上权衡的结果。如果值较高，例如1，此时会减少空间开销，但是 hash 冲突的概率会增大，增加查找成本；而如果值较低，例如 0.5 ，此时 hash 冲突会降低，但是有一半的空间会被浪费，所以折衷考虑 0.75 似乎是一个合理的值。

## 二狗：那我们换个问题问吧，HashMap 的插入流程是怎么样的？
囧辉：Talk is cheap. Show you the picture。

![image](https://pic1.zhimg.com/80/v2-3c9aa56b20ea776bd0ccf1e4584bfff8_1440w.jpg)


## 二狗：图里刚开始有个计算 key 的 hash 值，是怎么设计的？
囧辉：拿到 key 的 hashCode，并将 hashCode 的高16位和 hashCode 进行异或（XOR）运算，得到最终的 hash 值。
```
static final int hash(Object key) {
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
}
```
### 二狗：为什么要将 hashCode 的高16位参与运算？
囧辉：主要是为了在 table 的长度较小的时候，让高位也参与运算，并且不会有太大的开销。

例如下图，如果不加入高位运算，由于 n - 1 是 0000 0111，所以结果只取决于 hash 值的低3位，无论高位怎么变化，结果都是一样的。

![image](https://pic3.zhimg.com/80/v2-ef69c71651894ffd5ac56dd17b39e5b2_1440w.jpg)

